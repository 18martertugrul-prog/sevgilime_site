<!DOCTYPE html>
<html lang="tr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>AÅŸk Flappy ðŸ’–</title>

<style>
body{
    margin:0;
    background:#000;
    display:flex;
    justify-content:center;
    align-items:center;
    height:100vh;
    overflow:hidden;
    font-family:Arial, sans-serif;
}

#gameContainer{
    position:relative;
}

canvas{
    display:block;
    border-radius:12px;
}

#fullscreenBtn{
    position:absolute;
    top:10px;
    right:10px;
    padding:6px 12px;
    background:#ff69b4;
    color:white;
    border:none;
    border-radius:8px;
    cursor:pointer;
    font-size:14px;
}
</style>
</head>
<body>

<div id="gameContainer">
    <button id="fullscreenBtn">Tam Ekran</button>
    <canvas id="game"></canvas>
</div>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

/* ===== SABÄ°T ORAN ===== */
const BASE_WIDTH = 400;
const BASE_HEIGHT = 700;

function resizeGame(){
    let scale = Math.min(
        window.innerWidth / BASE_WIDTH,
        window.innerHeight / BASE_HEIGHT
    );
    canvas.width = BASE_WIDTH;
    canvas.height = BASE_HEIGHT;
    canvas.style.width = BASE_WIDTH * scale + "px";
    canvas.style.height = BASE_HEIGHT * scale + "px";
}
resizeGame();
window.addEventListener("resize", resizeGame);

/* ===== FÄ°ZÄ°K ===== */
const GRAVITY = 0.3025;
const JUMP = -6.2;
const MAX_FALL = 7;

let basePipeSpeed = 2.057;
let currentPipeSpeed = basePipeSpeed;

const PIPE_GAP = 195;
const PIPE_WIDTH = 60;
const PIPE_DISTANCE_PX = 260;
const GROUND_HEIGHT = 80;

let lastTime = 0;

/* ===== 30 SN GÃœNDÃœZ GECE DÃ–NGÃœSÃœ ===== */
let dayNightTimer = 0;
const DAY_NIGHT_DURATION = 30000; // 30 saniye

function lerp(a,b,t){
    return a + (b-a)*t;
}

function drawSky(deltaTime){

    dayNightTimer += deltaTime * 16.67;
    if(dayNightTimer > DAY_NIGHT_DURATION)
        dayNightTimer = 0;

    let t = dayNightTimer / DAY_NIGHT_DURATION;
    let cycle = Math.sin(t * Math.PI); 
    // 0 â†’ 1 â†’ 0 (gÃ¼ndÃ¼z â†’ gece â†’ gÃ¼ndÃ¼z)

    // GÃœNDÃœZ RENK
    let dayTop = {r:135,g:206,b:235};
    let dayBottom = {r:255,g:255,b:255};

    // GECE RENK
    let nightTop = {r:10,g:15,b:40};
    let nightBottom = {r:40,g:60,b:120};

    let r1 = lerp(dayTop.r, nightTop.r, cycle);
    let g1 = lerp(dayTop.g, nightTop.g, cycle);
    let b1 = lerp(dayTop.b, nightTop.b, cycle);

    let r2 = lerp(dayBottom.r, nightBottom.r, cycle);
    let g2 = lerp(dayBottom.g, nightBottom.g, cycle);
    let b2 = lerp(dayBottom.b, nightBottom.b, cycle);

    let gradient = ctx.createLinearGradient(0,0,0,canvas.height);
    gradient.addColorStop(0, `rgb(${r1},${g1},${b1})`);
    gradient.addColorStop(1, `rgb(${r2},${g2},${b2})`);

    ctx.fillStyle = gradient;
    ctx.fillRect(0,0,canvas.width,canvas.height);

    drawSunAndMoon(cycle);
}

/* ===== GÃœNEÅž & AY ===== */
function drawSunAndMoon(cycle){

    let angle = (dayNightTimer / DAY_NIGHT_DURATION) * Math.PI * 2;

    let orbitRadiusX = canvas.width/2 - 40;
    let orbitRadiusY = 200;

    let centerX = canvas.width/2;
    let centerY = 350;

    let sunX = centerX + Math.cos(angle - Math.PI/2) * orbitRadiusX;
    let sunY = centerY + Math.sin(angle - Math.PI/2) * orbitRadiusY;

    let moonX = centerX + Math.cos(angle + Math.PI/2) * orbitRadiusX;
    let moonY = centerY + Math.sin(angle + Math.PI/2) * orbitRadiusY;

    // GÃ¼neÅŸ (gÃ¼ndÃ¼zde gÃ¶rÃ¼nÃ¼r)
    ctx.globalAlpha = 1 - cycle;
    ctx.fillStyle = "#FFD54F";
    ctx.beginPath();
    ctx.arc(sunX,sunY,35,0,Math.PI*2);
    ctx.fill();

    // Ay (gecede gÃ¶rÃ¼nÃ¼r)
    ctx.globalAlpha = cycle;
    ctx.fillStyle = "#EEE";
    ctx.beginPath();
    ctx.arc(moonX,moonY,28,0,Math.PI*2);
    ctx.fill();

    ctx.globalAlpha = 1;
}

/* ===== SHAKE ===== */
let shakeTime = 0;
let shakePower = 0;

function applyShake(){
    if(shakeTime > 0){
        let dx = (Math.random()-0.5)*shakePower;
        let dy = (Math.random()-0.5)*shakePower;
        ctx.translate(dx,dy);
        shakeTime--;
    }
}

/* ===== KUÅž ===== */
let bird = {
    x: 90,
    y: 350,
    radius: 18,
    velocity: 0,
    rotation: 0
};

/* ===== OYUN ===== */
let pipes = [];
let score = 0;
let bestScore = localStorage.getItem("bestScore") || 0;
let gameOver = false;

/* ===== KONTROL ===== */
function jump(){
    if(!gameOver){
        bird.velocity = JUMP;
        bird.rotation = -20;
    } else {
        restart();
    }
}

document.addEventListener("keydown", e=>{
    if(e.code==="Space") jump();
});
canvas.addEventListener("touchstart", jump);

/* ===== BORU ===== */
function createPipe(){
    let min = 80;
    let max = canvas.height - PIPE_GAP - GROUND_HEIGHT - 80;
    let topHeight = Math.random()*(max-min)+min;

    pipes.push({
        x: canvas.width,
        top: topHeight,
        passed:false
    });
}

/* ===== Ã‡ARPIÅžMA ===== */
function checkCollision(pipe){
    if(
        bird.x + bird.radius > pipe.x &&
        bird.x - bird.radius < pipe.x + PIPE_WIDTH
    ){
        if(
            bird.y - bird.radius < pipe.top ||
            bird.y + bird.radius > pipe.top + PIPE_GAP
        ){
            shakeTime = 15;
            shakePower = 6;
            return true;
        }
    }
    return false;
}

/* ===== RESET ===== */
function restart(){
    bird.y = 350;
    bird.velocity = 0;
    bird.rotation = 0;
    pipes = [];
    score = 0;
    currentPipeSpeed = basePipeSpeed;
    gameOver = false;
}

/* ===== GAME LOOP ===== */
function update(timestamp){

    let deltaTime = (timestamp - lastTime) / 16.67;
    lastTime = timestamp;

    ctx.save();
    ctx.clearRect(0,0,canvas.width,canvas.height);

    drawSky(deltaTime);
    applyShake();

    if(pipes.length === 0){
        createPipe();
    } else {
        let lastPipe = pipes[pipes.length-1];
        if(canvas.width - lastPipe.x >= PIPE_DISTANCE_PX){
            createPipe();
        }
    }

    if(!gameOver){
        bird.velocity += GRAVITY * deltaTime;
        if(bird.velocity > MAX_FALL) bird.velocity = MAX_FALL;
        bird.y += bird.velocity * deltaTime;

        if(bird.velocity > 0){
            bird.rotation += 3 * deltaTime;
            if(bird.rotation > 90) bird.rotation = 90;
        }
    }

    pipes.forEach(pipe=>{
        pipe.x -= currentPipeSpeed * deltaTime;

        if(!pipe.passed && pipe.x + PIPE_WIDTH < bird.x){
            score++;
            pipe.passed = true;
            currentPipeSpeed += 0.08;
        }

        if(checkCollision(pipe)){
            gameOver = true;
        }
    });

    if(bird.y + bird.radius > canvas.height - GROUND_HEIGHT){
        shakeTime = 15;
        shakePower = 6;
        gameOver = true;
    }

    pipes.forEach(pipe=>{
        ctx.fillStyle="#2ecc71";
        ctx.fillRect(pipe.x,0,PIPE_WIDTH,pipe.top);
        ctx.fillRect(pipe.x,pipe.top+PIPE_GAP,
        PIPE_WIDTH,
        canvas.height - pipe.top - PIPE_GAP - GROUND_HEIGHT);
    });

    ctx.fillStyle="#8b5a2b";
    ctx.fillRect(0,canvas.height-GROUND_HEIGHT,canvas.width,GROUND_HEIGHT);

    // KuÅŸ
    ctx.save();
    ctx.translate(bird.x, bird.y);
    ctx.rotate(bird.rotation * Math.PI/180);
    ctx.fillStyle="#ffcc00";
    ctx.beginPath();
    ctx.arc(0,0,bird.radius,0,Math.PI*2);
    ctx.fill();
    ctx.restore();

    ctx.fillStyle="#fff";
    ctx.font="28px Arial";
    ctx.fillText("Skor: "+score,20,40);

    ctx.restore();
    requestAnimationFrame(update);
}

requestAnimationFrame(update);
</script>

</body>
</html>
